<template>
  <div class="main-view" v-if="isConfigLoaded">
    <div v-if="isLoading" class="loading-container">
      <div class="spinner"></div>
      <div class="text">submitting a result</div>
    </div>

    <div :class="isTrial ? 'timer-container-trial' : 'timer-container' ">
      Time: {{ formattedTime }}
      <button v-if="isPause && isTrial" @click="startAgain" class="ml-6" style="margin-right: 5px;">Start</button>
      <button v-if="!isPause && isTrial" @click="pause" class="ml-6" style="margin-right: 5px;">Pause</button>
      <button v-if="isTrial" @click="exit" class="ml-1">Exit</button>
    </div>

    <div class="line-container">
      <div class="line-turns">
        <canvas ref="lineCanvas" :width="width" :height="height"></canvas>
        <div class="question">
          <p v-if="config.left_turn && config.right_turn">
            How many Left Turns and Right Turns in the line?
          </p>
          <p v-else-if="config.left_turn">
            How many Left Turns in the line?
          </p>
          <p v-else-if="config.right_turn">
            How many Right Turns in the line?
          </p>
        </div>
      </div>
      <div class="answer-container" v-if="isShowAnswerBox">
        <input type="number" v-model="answer" required>
        <button @click="submitAnswer()">Submit</button>
      </div>
    </div>
  </div>
</template>

<script>
// import { removeTestByNameAndUpdateLocalStorage } from '@/utils/index'

export default {
  name: 'SpatialOrientation',
  data() {
    return {
      isConfigLoaded: false,
      isLoading: false,
      isTrial: this.$route.query.isTrial ?? false,
      isPause: false,
      isShowAnswerBox: false,
      width: 400,
      height: 400,
      answer: null,
      rightTurns: 0,
      leftTurns: 0,
      lines: [],
      collisions: 0,
      direction: 0,
      directions: [[1, 0], [0, 1], [-1, 0], [0, -1]],
      drawLineinterval: null,
      tailRemoveInterval: null,
      countdownInterval: null,
      config: {
        crash: null,
        duration: null,
        full_image: null, //true or false
        left_turn: null, //true or false
        right_turn: null, //true or false
        speed: null,
        speed_increasing: null, //true or false,
      },
    };
  },
  async mounted() {
    await this.initConfig();
  },
  methods: {
    pause() {
      this.isPause = true;
    },
    startAgain() {
      this.startCountdown();
      this.isPause = false;
    },
    exit() {
      this.$router.push('module');
    },
    setSpeed(speed) {
      return speed * 4000;
    },
    async initConfig() {
      try {
        let config = JSON.parse(localStorage.getItem('scheduleData'));

        if (config) {
          const spatialOrientation = await config.tests.find(test => test.testUrl === 'spatial-orientation-test').config;

          this.config.duration = spatialOrientation.duration * 60;
          this.config.batteryTestConfigId = spatialOrientation.id;
          this.config.sessionId = config.sessionId;
          this.config.userId = config.userId;

          // this.config.crash = spatialOrientation.crash,
          this.config.crash = 3,

          this.config.full_image = spatialOrientation.full_image, //true or false
          this.config.left_turn = spatialOrientation.left_turn, //true or false
          this.config.right_turn = spatialOrientation.right_turn, //true or false
          this.config.speed = this.setSpeed(spatialOrientation.speed),
          this.config.speed_increasing = spatialOrientation.speed_increasing, //true or false,

          this.isConfigLoaded = true;

          setTimeout(() => {
            this.generateLines();
            this.startCountdown();
          }, 1000);
        }
      } catch (error) {
        console.log(error, 'error')
      }
    },
    startCountdown() {
      this.countdownInterval = setInterval(() => {
        if (this.config.duration > 0) {
          this.config.duration--;
        } else {
          clearInterval(this.countdownInterval);
          clearInterval(this.drawLineinterval);
          clearInterval(this.tailRemoveInterval)

          // Submit Answer
          // setTimeout(() => {
          //   this.calculatedResult();
          // }, 1000);

        }
      }, 1000);
    },
    generateLines() {
      this.lines = [];
      this.rightTurns = 0;
      this.leftTurns = 0;
      this.collisions = 0;
      this.answer = null;
      this.isShowAnswerBox = false

      this.generateCoordinat();
      if (this.config.full_image) {
        this.drawLineAll();
      } else {
        this.drawLineSlow()
      }
    },
    generateCoordinat() {
      const length = Math.floor(Math.random() * (50 - 20 + 1)) + 30;
      const visitedCoordinates = new Set();

      let x = this.width / 2;
      let y = this.height / 2;
      this.lines.push({ 'x': x, 'y': y });
      visitedCoordinates.add(`${x},${y}`);

      if (this.config.crash === 0) {
        const totalLength = Math.floor(Math.random() * (20 - 10 + 1)) + 10;
        for (let i = 0; i < totalLength; i++) {
          let newX, newY, validCoordinate;

          do {
            const turn = Math.random() < 0.5 ? -1 : 1;
            this.direction = (this.direction + turn + 4) % 4;

            newX = x + this.directions[this.direction][0] * length;
            newY = y + this.directions[this.direction][1] * length;

            // Keep Within Bounds
            newX = Math.max(0, Math.min(this.width, newX));
            newY = Math.max(0, Math.min(this.height, newY));

            // Cek apakah koordinat baru valid
            validCoordinate = !visitedCoordinates.has(`${newX},${newY}`) && !(newX === x && newY === y);

          } while (!validCoordinate);

          x = newX;
          y = newY;
          this.lines.push({ 'x': x, 'y': y });
          visitedCoordinates.add(`${x},${y}`);
        }
      }

      if (this.config.crash > 0) {
        this.collisions = 0;
        let newX, newY, validCoordinate;

        while (this.collisions < this.config.crash) {
          const turn = Math.random() < 0.5 ? -1 : 1;
          this.direction = (this.direction + turn + 4) % 4;

          newX = x + this.directions[this.direction][0] * length;
          newY = y + this.directions[this.direction][1] * length;

          // Keep Within Bounds
          newX = Math.max(0, Math.min(this.width, newX));
          newY = Math.max(0, Math.min(this.height, newY));

          validCoordinate = visitedCoordinates.has(`${newX},${newY}`);

          if (validCoordinate) {
            this.collisions++;
            console.log('kesini')
            this.lines.push({ 'x': newX, 'y': newY });
          } else {
            x = newX;
            y = newY;
            this.lines.push({ 'x': x, 'y': y });
            visitedCoordinates.add(`${x},${y}`);
          }
        }
      }
    },
    drawLineAll() {
      const canvas = this.$refs.lineCanvas;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, this.width, this.height);

      for (let i = 0; i < this.lines.length - 1; i++) {
        if (i === 0) {
          ctx.beginPath();
          ctx.moveTo(this.lines[i].x, this.lines[i].y);
        } else {
          ctx.lineTo(this.lines[i].x, this.lines[i].y);
          this.countTurns(i);
        }
      }

      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.stroke();

      this.drawArrowHead();
      this.startTailDisappearance();
    },
    drawLineSlow() {
      const canvas = this.$refs.lineCanvas;
      const ctx = canvas.getContext('2d');

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let i = 0
      this.drawLineinterval = setInterval(() => {
        if (i === 0) {
          ctx.beginPath();
          ctx.moveTo(this.lines[i].x, this.lines[i].y);
        } else {
          ctx.lineTo(this.lines[i].x, this.lines[i].y);
          this.countTurns(i);
        }

        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.stroke();

        if (i < this.lines.length - 1) {
          i++
        } else {
          this.stopInterval();
          this.drawArrowHead();
          this.startTailDisappearance();
        }
      }, this.config.speed);
    },
    countTurns(index) {
      const prevPoint  = this.lines[index - 1];
      const currPoint = this.lines[index];

      if (prevPoint .x < currPoint.x) {
        this.rightTurns++;
      }
      if (prevPoint .x > currPoint.x) {
        this.leftTurns++;
      }
    },
    drawArrowHead() {
      const canvas = this.$refs.lineCanvas;
      const ctx = canvas.getContext('2d');

      // Memastikan ada cukup titik untuk menggambar panah kepala
      if (this.lines.length < 2) return;

      // Titik akhir dan titik sebelumnya
      const end = this.lines[this.lines.length - 1];
      const start = this.lines[this.lines.length - 2];

      // Hitung sudut garis
      const angle = Math.atan2(end.y - start.y, end.x - start.x);
      const headlen = 10; // Panjang panah

      // Tentukan koordinat titik kiri dan kanan panah
      const leftX = end.x - headlen * Math.cos(angle - Math.PI / 6);
      const leftY = end.y - headlen * Math.sin(angle - Math.PI / 6);
      const rightX = end.x - headlen * Math.cos(angle + Math.PI / 6);
      const rightY = end.y - headlen * Math.sin(angle + Math.PI / 6);

      // Gambar garis utama
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();

      // Gambar panah kepala
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(end.x, end.y); // Titik akhir garis (tengah panah)
      ctx.lineTo(leftX, leftY); // Titik kiri panah
      ctx.lineTo(rightX, rightY); // Titik kanan panah
      ctx.closePath();
      ctx.fill();
    },
    stopInterval() {
      clearInterval(this.drawLineinterval);
      this.drawLineinterval = null;
    },
    startTailDisappearance() {
      const canvas = this.$refs.lineCanvas;
      const ctx = canvas.getContext('2d');
      let i = 0;

      ctx.clearRect(0, 0, this.width, canvas.height);

      ctx.beginPath();
      ctx.moveTo(this.lines[0].x, this.lines[0].y);
      for (let j = 1; j < this.lines.length ; j++) {
        ctx.lineTo(this.lines[j].x, this.lines[j].y);
      }
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.stroke();

      this.drawArrowHead();

      this.tailRemoveInterval = setInterval(() => {
      if (i < this.lines.length - 2) {
        ctx.clearRect(0, 0, this.width, this.height);

        ctx.beginPath();
        ctx.moveTo(this.lines[i + 1].x, this.lines[i + 1].y);

        for (let j = i + 2; j < this.lines.length - 1; j++) {
          ctx.lineTo(this.lines[j].x, this.lines[j].y);
        }

        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.stroke();

        this.drawArrowHead();

        i++;
      } else {
        clearInterval(this.tailRemoveInterval);
        this.tailRemoveInterval = null;

        this.drawArrowHead();

        this.isShowAnswerBox = true
      }
    }, 2000);
    },
  },
  computed: {
    formattedTime() {
      const minutes = Math.floor(this.config.duration / 60).toString().padStart(2, '0');
      const seconds = (this.config.duration % 60).toString().padStart(2, '0');
      return `${minutes}:${seconds}`;
    },
  },
};
</script>

<style scoped>
  .main-view {
    justify-content: center;
    align-items: flex-start;
    gap: 20px;
    margin: 60px auto;
  }
  .timer-container-trial {
    position: absolute;
    right: 0;
    top: 0;
    background-color: #0349D0;
    padding: 0.75rem;
    color: #ffffff;
    font-weight: bold;
    border-bottom-left-radius: 15px;
  }
  .timer-container-trial button {
    color: #000000;
    font-weight: bold;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    border-radius: 5px;
    border-color: transparent;
    min-width: 100px;
    cursor: pointer;
  }
  .timer-container {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    background-color: #0349D0;
    padding: 1.5rem 5rem;
    color: #ffffff;
    font-weight: bold;
    border-bottom-left-radius: 15px;
    border-bottom-right-radius: 15px;
  }
  .loading-container {
    /* Add your loading indicator styles here */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    /* Black background with 80% opacity */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    /* Ensure it is above other content */
  }
  .spinner {
    border: 8px solid rgba(255, 255, 255, 0.3);
    /* Light border */
    border-top: 8px solid #ffffff;
    /* White border for the spinning part */
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1s linear infinite;
  }
  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }
  .text {
    color: #ffffff;
    margin-top: 20px;
    font-size: 1.2em;
  }
  .line-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .line-turns {
    position: relative;
    margin-bottom: 20px;
    margin-top: 20px;
  }
  canvas {
    border: 1px solid #000;
    background-color: white;
  }
  .question {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 1em;
    font-weight: bold;
  }
  .answer-container {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }
  button {
    padding: 10px 20px;
    font-size: 1em;
  }
</style>
